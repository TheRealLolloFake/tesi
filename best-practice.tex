\chapter{Best practices}\label{ch:best}
As an IoT application is designed as illustrated in Figure \ref{fig:best0}, the development of an IoT application is split on two sides:
\begin{enumerate}
	\item IoT side - The part of the application that deals with sensors, devices and handles the communication between them and the main server.
	\item Client side - The part of the application that allows the final user to control the application.
\end{enumerate}


	\begin{figure}
	\includegraphics[width=\linewidth]{bestpractice-img0.png}
	\caption{One possible architecture of an IoT application.}
	\label{fig:best0}
\end{figure}

In order to develop a secure IoT application we must work on both sides; we have seen, in the previous chapter, how to attack and secure the communication between IoT devices and the main server, but we have not talked about the client side.\newline

The client side of an IoT application can be developed in different ways, from a web application to a stand-alone application for desktop or smartphone.\newline
From my experience in the company, the client side is developed as a web application in order to make it available both on desktop and smartphone without the need of developing two different applications.\newline
It is important to highlight that each side must be treated with care, in fact it is useless to focus only on one side and leave the other completely insecure; an attacker will exploit the weak link to compromise your application, so the overall security of your system is equal to the weakest link in the chain.\newline
Basically, the same effort must be done on both sides of the application.\newline

In this chapter, we list down and discuss the best practices to follow in order to write secure IoT applications from the client side point of view.\newline
I want to highlight that these best practices are not strictly related to IoT,.\newline
We provide code to support my discussion where possible; if the use of code is not easy, we use pseudo-code instead.\newline

\section{Never trust the client}
During the development of an application with client/server architecture, communications between the two parts is essential, but in order to develop a bulletproof application it is important to always check received data.\newline

In order to have an example in mind we refer to the classic web application model where the client side runs on a browser, like Mozilla Firefox or Google Chrome, and where the server side is written in PHP or similar languages.\newline

Even if we develop the client, the server must perform a check of the  received data; the client could be used by a malicious user or the attacker may send data to our server without the aid of the client application with tools like cUrl, Postman or netcat.\newline

Basically, when the server receives some data, before performing any operation, it must:
\begin{enumerate}
	\item Authenticate the user if required.
	\item Check if the data conforms to business application rules.
	\item If the provided data are used in a query, sanitize them.
	\item If the user is authenticated, check if he has the privilege to execute the operation requested.
	\item Send back the result if necessary.
\end{enumerate}

Now we discuss in the details these five points.\newline

\begin{enumerate}
	\item	Most of the time, in order to provide a service or to allow the user to perform a certain action on our web application, we want to authenticate the user. Sometimes this is not true, for instance, when a user does not have an account for our application we want to provide him a way to sign in. In this particular case we are allowing a user to execute an operation without authentication, just because he does not have login credentials; note that the sign in of a user is a very critical point in your application.
	\item At this point we want to check if the received data from the user are conforming to what we expect, for instance if we expect to receive a short comment limited to 260 characters, we must check that the provided comment does not exceed such a limit. If we are dealing with an uploaded file from a user, it is extremely important to check if the provided file is not a malicious one, for instance suppose that we receive an image from the user; simply checking the extension of a file is absolutely a bad idea, in fact the extension of a file can be changed, thus it is possible to save a malicious executable program as a .png and upload it to a remote server, a better way to check that the uploaded image is really an image is checking the magic number, also known as the file signature, used to identify or verify the content of a file.
	Note that each type of data may need particular care, file are more complex to check instead of raw data like strings or integers.
	\item In order to avoid SQL injection, data loss and data leak, it is important to always sanitize data used as a parameter for a query, a SQL injection may drop the entire DB, or could silently leak information like username or password hash (I hope you do not have passwords saved as plain text). Nowadays is quite trivial to avoid these kind of attacks with the aid of prepared statements which allows us to bind parameters in query in a safe way.
	In general, prepared statement are supported by DB library of every important programming language and most of the case can be handled nicely with them.
	Anyway there are cases where using a prepared statement is infeasible; for instance, if you want to allow a user to write down a query and execute it, using a prepared statement is difficult or even impossible, so you need to manually check the provided query.
	These warnings are valid even for NoSQL systems, in this particular case there are no standard like SQL, so it may be more difficult to avoid them considering that there are no standard techniques.
	\item It is important to check the privilege associated to a user because we do not want everyone to execute operations that may change drastically our server application or even destroy it; without proper control, even the user with lowest privilege may execute reserved operation.
\end{enumerate}

The golden rule is: never trust the client.

\section{Always check data from the server}
As we have seen, a server must not trust inputs from a client and it must sanitize them before using them; from the point of view of a client, could seem strange to doubt the server, but in reality the client must treat with care data, received from the server, because it could be a corrupted server or even a fake one.\newline
The scenarios are the following:
\begin{itemize}
	\item An attacker has taken control of the server and uses it to send malicious data.
	\item A DNS server has been corrupted by an attacker, or the client is a victim of a poison attack, so when a client tries to obtain the address of the legitimate server, it is redirected to
	a corrupted server.
\end{itemize}

Let us see a flaw in a web application.

\begin{lstlisting}[language=html]
//page.html
<html>
	<meta charset='UTF-8'>
	<head><title>Test</title></head>
	<body>
		<div id='placer'></div>
		<script scr='vuln.js'></script>
	</body>
</html>
\end{lstlisting}

\begin{lstlisting}[language=Javascript]
//vuln.js
var req=new XMLHttpRequest();
req.onreadystatechange=function(){
	if(this.readyState==4 && this.status==200){
		var placer=document.getElementById('placer');
		placer.innerHtml=this.responseText;
	}
};
req.open('GET','malicious.php',true);
req.send();
\end{lstlisting}

\begin{lstlisting}[language=php]
//malicious.php
<?php
	echo '<img src=1 hidden onerror=alert("VULNERABLE!")>';
?>
\end{lstlisting}

The client side code is composed by an HTML webpage and a JavaScript code that perform an AJAX request to the \texttt{malicious.php} page on the server.\newline
In this case we chose to use an AJAX request for simplicity, but nothing forbids us from using a WebSocket.\newline
While the server simply sends back a string, this string contains JavaScript code.\newline
The problem here is that the client, in order to show the data received from the server, to the final user, copies the content of \texttt{responseText} in the \texttt{innerHtml} of the \texttt{div} with \texttt{id='placer'}.
In this particular case the data is expected to be text, in reality its is an HTML image tag containing JavaScript code for error handling (the image will never load). This code is added to the DOM and the code executed.\newline
In this case the code is a simple alert and does nothing to harm the client, but in a real scenario the malicious script will not be something so simple.\newline
The main problem here is that the client assumed that the data was safe and copied it to the innerHtml of a DOM element without sanitizing it.\newline

The \texttt{innerHtml} attribute of a DOM element is an easy way to add content to a web page, but it is also the easiest way to introduce vulnerabilities in your page.
In order to avoid such a trivial exploit it is recommended to sanitize the input before placing it on the DOM.\newline

On the internet, you can find this nice piece of code to sanitize a string:
\begin{lstlisting}[language=Javascript]
	function sanitize(var content){
	var elem=document.createElement('div');
	elem.innerHTML=content;
	return elem.innerText;
	}
\end{lstlisting}


The problem about this function is that it does not provide any security, so always check what you copy and paste in your code; not always what is claimed is really what the code does.\newline
There are libraries around the web that provide function to sanitize strings, one of the most famous is surely jQuery, it also offers other features. The \texttt{html()} function is great to avoid unwanted code execution when you need to place data on the DOM.\newline
The following could be the structure of a correct handling of data received from the server.\newline
\begin{lstlisting}
var placer=document.getElementById('placer');
var sanitized=html(this.responseText);
placer.innerHtml=sanitized;
\end{lstlisting}
An easy way to sanitize strings is to rely on well-known libraries, but if for some reason you could not use them, the solution is to write your own sanitation function that will likely use regular expressions. Be careful because it could be more difficult than expected and error prone, so test your code with care before using it in a release environment.\newline

\section{Password handling}
Password handling is a very critical section of every application, passwords are sensitive data that must be treated carefully at different levels, we analyze how to handle password from the code and database perspective.\newline

\subsection{Handling password in code}
A password must be handled in a special way, in lots of code you can find snippets like the following:
\begin{lstlisting}[language=java]
String username="user0";
String password="mypass0";

login(username,password);
\end{lstlisting}

The real problem here is that the password is handled as a String, in high level languages like Java or C\#, strings are immutable, this means that a string cannot be modified in any way, so even if we change the reference in this way:
\begin{lstlisting}[language=java]
password="";
\end{lstlisting}

We are not erasing the previous password content, we are changing the reference of the variable \texttt{password}, so the previous data are somewhere in memory, and it will be overwritten only when the garbage collector mark the area of memory as free and new data is allocated in this particular area.\newline
If an attacker can dump the process or perform a cold boot attack, he can steal login credentials and other sensitive data.
It is important to highlight that if an attacker can perform the previous operation you also have to deal with the fact that your system is vulnerable and compromised in some ways, or that the machine where the program runs is accessible to malicious users.\newline
In order to avoid data leak, we want to reduce the exposure of sensible data in our application as much as possible.\newline
To overwrite a password, we need a data structure that allows this operation, the easiest way is to use an array of character instead of a string, just in the way we deal with strings in low-level languages like C.\newline
So, the previous snippet of code change in this way:
\begin{lstlisting}[language=Java]
String username="user0";
char[] password={'m','y','p','a','s','s','0'};

login(username,password);
\end{lstlisting}


The main drawback of using an array of character is that is not comfortable, it obliges us to write code a bit more complex, and we do not have access to the utility function of the string class.
When the password is needed no more in our code we need to erase the content of the password, this could be done easily with this utility function:
\begin{lstlisting}[language=Java]
	public void destroy(char[] arr){
		for(int i=0;i<arr.length;i++)arr[i]=’0’;
	}
\end{lstlisting}

Always remember to erase the data when it is no more needed, otherwise all the work done to secure the password handling is wasted.\newline
When you are dealing with a password, it is likely that you want to hash or encrypt it, most of the times cryptographic libraries deals with array of bytes, converting an array of chars to an array of bytes is trivial so designing your system with this knowledge in mind could help you.\newline
Also remember that if you convert an array of characters to an array of bytes, the previous one is no more needed so erase its content and deal with the second one until you have finished your task, and remember to erase this one too.\newline
Basically, what we are trying to do is limiting the exposure of sensitive data in memory as much as possible; of course if an attacker dump the process when the password is exposed, there is no way to avoid the leak, but with this little trick we can make the task more difficult.\newline
Sometimes it may not be possible handle a password in this way for lots of different reason.\newline
For example in high level scripting language like JavaScript the primitive type char does not even exists, there is no easy way to handle a password without a string, you may think to handle it like an array of numbers, but it may be overkilling.\newline
Another example is the bad design of a library, suppose that you buy an API that require a login and the signature of the login function is the following:
\begin{lstlisting}
void login(String usr, String pwd);
\end{lstlisting}

In situation like that, there is nothing we can do: we cannot edit the signature and we must adapt our code in order to provide a String to the function.\newline
Handling the password like a character array is meaningless if you then need to convert it to a String.\newline

In C\# there is a special object called \texttt{SecureString} that provides a way to deal with passwords in a secure way. The content of a string is created by inserting single characters and the content of the string is encrypted in memory.\newline
It seems like a great way to deal with password but some of the API of C\# that requires a password as argument expect a String, so the utility of this object is not so high, also note that it does not provide any access to the content of the string (and sooner or later we will need to use the content): the only way to access it is to convert the \texttt{SecureString} object to a String with the aid of the static method \texttt{SecureStringToGlobalAllocUnicode(…)} of the \texttt{Marshal} class, which returns a \texttt{IntPtr} that can be converted in a \texttt{String} with the static method \texttt{PtrToStringUni(…)} of the \texttt{Marshal} class, but doing that simply throws away all the effort made in order to secure the password in memory, considering that we are dealing again with a \texttt{String}.\newline

\subsection{Handling password in database}
Passwords are, most of the times, stored in a database. We are not interested in specifying which one because what we are about to say is valid for every system.\newline
The first thing we want to highlight is: do not store password as plain text in your database.\newline
If you store password as plaintext in your database, and an attacker steal your data, you are allowing access to your system freely.\\

Suppose that you are dealing with an e-commerce website, if an attacker could access as the user X it is likely it will be allowed to buy items with the credit card of X, or even steal the credit card number.\\
This will translate in problems and hassles for the user and to an even big problem for you, and we have not even talked about the damage of image for your company, if the affair become of public domain (and it will, sooner or later).\\
In order to store password in a secure way we need three ingredients:
\begin{enumerate}
	\item A cryptographic hash function or a key derivation function.
	\item A salt generated from secure pseudo-random number generator.
	\item A number of iterations.
\end{enumerate}

A cryptographic \emph{hash function} is a special hash function that maps data of arbitrary size to a bit string of fixed size, designed to be one-way, in other word a function that is infeasible to invert.\\
A key derivation function is a cryptographic function that derive a secret key from a secret value such as a password.\\
The main difference between the two is that a key derivation function has a randomness property that is absent in a cryptographic hash function.\\
From now on, we will refer to both with the term hash function in order to make our exposure a bit simpler.\\
A \emph{salt} is a sequence of random bits used together with the password as input for the hash function. When we say random we are referring to value generated with secure pseudo-random number generator, the common random number generator provided by all the standard libraries of programming languages are not appropriate for this kind of task.\\
The number of iterations is simply the number of times a particular hash function is executed in order to produce the output.\\

Storing a password as hash is recommended because if someone steal your database, it may be capable of reading the users’ records, on the other hand he will not be able to login because the password is not stored as plain text but as hash.\\
The login procedure (server side) takes a plain text password, calculates the hash from it and compares it with the one stored in the database; if the two hashes are the same, then the access to system is granted, otherwise it is not.\\
In other words, the only way to access the system with the credentials of another user is to steal them with social engineering’s technique, guessing it with a dictionary attack or cracking it with a brute force attack.\\
Note that if an attacker has access to the database he can find users with the same password hash, this means that different users have the same password (if the salt is not used), so stealing the password of user1 means stealing also the password of user2.\\
If an attacker has stolen a database and cracks the password of user X, it could be that the user X use the same password for different services, so if the attacker is able to break one hash he could gain the access even to other system. In this case it is not only a fault from the development team, but also from the user that used the same password.\\
There are also brute force attacks that are particularly efficient because they work with large pre-computed hash table known as rainbow tables: we need to introduce a salt in order to make the use of these table useless.
To avoid this kind of attack we are adding a random value known as salt in order to produce a different output every time the hash function is executed with the same password as input.\\
The salt is a value that must be saved with the hash, otherwise we could not produce again the hash that matches the one saved in the database.\\
With the aid of salt, we can make the use of a rainbow table useless because the attacker must know the salt: only after that he can start a brute force attack that may takes a lot time if the password is not trivial.\\

It is also important to iterate the hash function a certain number of times in order to slow down the cracking attempt of an attacker.\\
First of all, if the number of iterations is not known, the attacker must try all the passwords and hash them $n$ times, where $n$ is the number of iterations he has estimated.\\
The number of attempts can be saved on the users’ record without problem, of course if an attacker steal your database he will know the value of $n$, but if all the precautions are applied he basically has no way to succeed with a brute force attack.\\
It is important to design your system in a way that allows to customize the number of iterations during the years, that is because the computational power increases every year, so if a number of iterations $m$ was safe two years ago, it may be insecure nowadays, if you design your application in a good way you can simply tune up it up from a configuration file.\\


The code that performs the login could be something similar to the following snippet:
\begin{lstlisting}[language=Java]
var username=”user”;
var password={”p","a","s","s","w","o","r","d”};
var iter=readIterationFromConfigFile();
var user=getUserFromDB(username);
if(user==null)return error;

var hash=hashFunction(password,user.salt,user.iter);
if(hash!=user.password)return error;

if(iter!=user.iter){
	var newSalt=SecureRandomNumberGenerator.generate();
	var newHash=hashFunction(password,newSalt,iter);
	updateUserInDB(username,newHash,newSalt,iter);
}
return access granted;
\end{lstlisting}

Until now we have been generic about which hash function to employ, for this reason here an overview of the most common hash function.

\input{table/011-hash}

\paragraph{MD5} is a hash function producing a 128 bit output.\\
It is considered an insecure function because it suffers from extensive vulnerabilities.\\
Even if the vulnerability is known by some years it remains in use.\\
The main vulnerability is about collision, generally when a collision is found; the hash function is no more secure.\\
So if you need to choose a hash function for your application, do not choose MD5~\cite{md5}.\\


\paragraph{SHA} is a family of cryptographic hash functions composed by:
\begin{itemize}
	\item SHA-0 - It was the first algorithm that produced a 160 bit hash, it was marked as insecure shortly after its publication.
	\item SHA-1 - Released shortly after SHA-0, it produces a 160 bit hash, since 2010 it is considered secure no more for cryptographic uses.
	\item SHA-2 - It is a sub-family of hash functions, with different block sizes: 256 and 512.
	There are also truncated versions with block size of 224 and 384.
	\item SHA-3 -It is a hash function with different block sizes: 256 and 512, its internal structure is completely different from the rest of the SHA family.
	We will not consider SHA-0 and SHA-1 as candidates because they are not secure as cryptographic hash function, SHA-1 is still used for other tasks such as MAC~\cite{sha}.
\end{itemize}


\paragraph{Bcrypt} is based on the Blowfish block cipher algorithm and it is a password hashing function.\\
In order to use it we must provide: a password, a salt and the number of iteration.\\
This function is designed to be slow on hardware like GPU, in order to achieve this result, Bcrypt heavily relies on accesses to a table which is altered during the execution of the algorithm, this is fast on a CPU, but in a GPU this translates in a slowdown due to the fact that the memory is shared by all cores and they compete for the control of the memory bus.\\
On the other hand Bcrypt is weak to ASIC attack considering that it is possible to implement Bcrypt in ASIC efficiently~\cite{bcrypt}.


\paragraph{Scrypt} is a key derivation function designed to make it costly to perform large scale custom hardware attacks by requiring a large amount of memory.\\
Scrypt can be considered as an evolution of Bcrypt because it is similar to it.\\
In order to use this function we need to provide: a password, a salt and the number of iterations.\\
The output produced by this function can be used as a hash and also as a cryptographic key.\\
Scrypt is considered memory intensive because it creates a lot of pseudo-random number that are used a few times during the computation, generating the number is computationally intensive and it makes sense to store them in RAM instead of re-computing them on the fly~\cite{scrypt}.\\


\paragraph{PBKDF2} is a key derivation function that applies a pseudo-random function.
In order to use this function we need to provide: a password, a salt and the number of iteration.\\
The output produced by this function can be used as a hash and also as a cryptographic key.\\
PBKDF2 is strong against brute force attack due to the variable number of iterations and thanks to the salt it is also resistant to rainbow table attacks.\\
PBKDF2 is weak to attacks performed with ASIC or GPU, in fact this function need very little RAM, thus brute force attacks with these specific tools are relatively cheap and they can provide good performance during a password cracking task~\cite{pbkdf2}.\\

Therefore, I suggest using Bcrypt or PBKDF2: they are reliable and supported in most cryptographic libraries.\\
The standard library for high level languages like Java or C\# offers good support for cryptographic functions, on the other hand if you work with low level languages like C or C++ I suggest you to rely on a cryptographic library.\\


In Table \ref{tab:table12} there is a list of natively supported hash/key derivation function for different languages.\\

\input{table/012-hashes-availability}

\subsection{Handling password embedded in the code}
Sometimes it is possible to find sensitive data inside a program; think about the last time you wrote an application which connects to a database, where did you stored the credentials to access it?\\
Most of the time these data are hard-coded in the program, sometimes they are stored as plain text in configuration file.\\
Using an encrypted configuration file is not a good idea because you need to store a key somewhere, and often the key is hard-coded in the program so there is no difference with the two previous options.\\

Also note that hard coding credential in your code is a bad practice because you will need to compile it again if you change them, another thing to keep in mind is that your code is likely to be saved on versioning systems like Git or Subversion. If one of this system is violated, then an attacker can read your code and steal your credentials.\\

We list some possible ways to store passwords or keys in a secure way, from the best to the worst.\\
\begin{enumerate}
\item Hardware security module - An HSM is a product designed to store credentials, private keys and sensitive data in general.
The main drawback of a HSM is its cost, an entry level HSM may cost you at least 2000\$, and then you also need to take care to implement it in your system.
\item Trusted platform module - A TPM is a microprocessor specifically designed to perform cryptographic operations.
It could be seen as a cheap alternative to a HSM.
\item Encrypting the sensitive data with the login password of your OS.
This could be a good solution if your OS stores your login password in a secure way and it is possible to access it in order to derive a key that will be used to encrypt the configuration file.
Windows has an API that allows you to perform these kind of tasks.
\item Store the sensitive data in a different machine.
In this case the application does not have the credentials available and it must receive them from another machine at runtime. You are moving the problem to another machine because you will need to find a way to store these sensitive data, also note that the communication must be encrypted and that if the remote machine is unreachable the main application is susceptible to denial of service.
\item Hardcode the sensitive in your code.
This is not a good solution but it can defend you from script kiddies that are not able to analyze your code with an hex editor or a disassembler.
\item Save the sensitive data in a plain text configuration file.
Are you serious?
\end{enumerate}

Storing credential is not an easy task because you need to take into account: cost, security and ease of implementation.\\
Cost is very important because it is strictly tied to the security level you want to achieve: using an HSM is surely the best option from a security point of view, but for a small development team its cost may be prohibitive.\\
It is necessary to find out a trade off that makes it possible to achieve good security but also respect the budget, also taking into account that some solutions could be an overkill for the environment of your application.\\

\subsection{Handling password from the user point of view}
Most of the time a user password is very simple, and ``password'' is always in the top ten easiest password to crack.\\
Even if we use a secure system, the weak link is, most of the time, the user.\\
Enforcing the use of complex passwords with uppercase, lowercase letter, at least one special character and a number is not a great idea for three reasons:
\begin{enumerate}
	\item It will be difficult to remember for the user.
	\item An attacker knows the structure of the password.
	\item The user will use ``Password1!''.
\end{enumerate}

When a password is difficult to remember it is likely that the user will write it down on paper or save it on a plain text file on his computer.\\
On other hand, if an attacker knows the structure of the password it can focus only on certain combinations and having a little speed up during the cracking process.\\

I suggest to avoid mandatory complex password because I think it is not a good way to provide security, instead I suggest to use long easy to remember passwords, in fact the length of a password could save us from a brute force attack quite easily.\\
Do not impose a limit on the maximum length of the password, but impose a minimum length of at least 8 characters, even if 8 characters are easy to crack.\\
The following password can be cracked easily with a modest system:\\
\texttt{"qv£a/l4p"} - 8 characters password.\\
In addition, it is difficult to remember; on the other hand a simple password like:\\
\texttt{"lion cucumber skateboard snake beer"} - 36 characters password.\\
Is difficult to crack and easy to remember.

\section{Never write your own cryptographic functions}
When dealing with cryptographic functions, is not a good idea to implement a certain cryptographic function from scratch, but it is better to use a cryptographic library that implements it.\\
Dealing with cryptographic functions is not easy and it requires lots of care in order to avoid bugs that could lead to serious security issues in future.\\
Of course, a library could be bugged, but behind well-known libraries there are expert programmers and we assume that these libraries are secure and overhauled.\\

Another thing to notice is that you should not create your own cryptographic schema, even if it may seems unbreakable to you, it does not mean it is in reality.\\
A secure cryptographic scheme is created by experts in cryptography and analyzed by other experts and it could take some years before a scheme is considered secure.\\
Take also in mind that security through obscurity is not a good idea, even if you create your cryptographic scheme and you keep it secret, it does not mean it can not be cracked.\\
In this case it is appropriate to remember the second Kerckhoffs's principle:
A cipher should not require secrecy, and it should not be a problem if it falls into enemy hands.\\

\section{Preventing SQL Injection}
SQL Injection is one of the most famous attack performed over the last 20 years.\newline
It simply relies on the negligence of programmers that trust user's input, if the input is used to perform
a query on a DB, the consequences can be devastating.\newline

An example of SQL Injection is the following:

\begin{lstlisting}
	String query="SELECT * FROM X WHERE Y="+param;
	
	execute(query);
\end{lstlisting} 

The parameter \texttt{param} is concatenated with the query string without any control, if the content of this variable is, for instance:
\texttt{'"bobby"; DROP DATABASE db;'} the query will be performed, but another one will be performed too ... and it will drop the database.\newline

Of course, it is also possible to leak data with this kind of technique and it could be done silently without any harm to the DB, so it will be quite difficult to
find out a data leak in this condition.\newline

In order to avoid this kind of attack, the programmer must check every parameter that is concatenated in the query string in order to be sure that nothing that could harm
the system is concatenated in the query.\newline
There are four general case that we must take care:
\begin{itemize}
	\item String - a string must be enclosed in quotes and special characters have to be escaped; or the string must be hex-encoded.
	\item Numbers - a number must contain only digits, a decimal delimiter and a sign.
	\item Identifiers - an identifiers must be enclosed in backticks and special character have to be escaped.
	\item Operator and keyword - there is no general rule, they have to be legitimate operators and keywords.
\end{itemize}

Checking every parameter in a manual way is not a great idea for three reason: it is boring, will bloat your code and it is likely that you forget to check
some parameters; for these reason we need an automatic way to check the input. Another approach that is quite more reliable is based on Prepared Statement,
a prepared statement is a particular object that allows the execution of certain statement repeatedly with high efficiency.\newline
A particular feature of prepared statement is that query and parameters are sent to the DB server separately, basically we are sending a program to the server and then its input;
and we are no more mixing these two things together.\newline

In general, a prepared statement works in this way:

\begin{lstlisting}
String query="SELECT * FROM X WHERE Y=?";

PreparedStatement ps=new PreparedStatement(query);
ps.bind(0,"pippo");

execute(ps);
\end{lstlisting}

The ? is used as placeholder and then a parameter is bound in its place.\\

The general rule is: when dealing with dynamic input data, use a prepared statement and you \emph{should} be safe.\\
I said \emph{should} because there is one little detail that is not always mentioned while talking about prepared statements,
a prepared statement supports only two kinds of literals: string and number, so identifiers, operator and keyword are left uncovered~\cite{phpinj}.\\
There are also cases where a prepared statement is not good at all, for example if the query is dynamic, there is no way to use a prepared statement
easily, in this case the programmer should implement the feature with particular care.\\

In order to avoid damages to the DB if a SQL injection occurs, it is recommended to use permission on tables in order to deny certain dangerous operations
for the user that executes the query on the DB, this also means that you should design the user's privilege in order to be the lowest as possible.\\ 


\section{Writing a secure login form}
Writing a login form is one of the most common task that a developer, sooner or later may face in his career.\\
So writing it in a secure way is important, in this section we will show that using the proper hash function is not enough.\\
The first thing we want to highlight is that the communication between client and server must be encrypted, otherwise an attacker could steal the credentials trivially.\\
If you are dealing with a web application, always remember to send login credential with a POST request, otherwise with a GET request username and password will be encoded in the URL; this can avoid trivial attacks by script kiddies but an expert attack will not be fooled.\\
We will start from this basic login code (server side).\\
\begin{lstlisting}[language=Java]
bool login(String username,char[] password){
	int iter=readIterationFromConfigFile();
	User user=getUserFromDB(username);
	if(user==null)return false;
	String hash=hashFunction(password,user.salt,user.iter);
	if(hash!=user.password)return false;
	if(iter!=user.iter){
		String newSalt=SecureRandomNumberGenerator.generate();
		String newHash=hashFunction(password,newSalt,iter);
		updateUserInDB(username,newHash,newSalt,iter);
	}
	return true;
}
\end{lstlisting}



This is a good starting point, but we need to add some little details in order to avoid: time attacks and denial of service.\\
A time attack is a side channel attack that allows an attacker to infer some information based on the time elapsed from the start of a request and its end.\\
In the particular case of a login task, an attacker could infer if an account exists or not.\\
As you can see from the code, if the user is not on the database the function will return false and will not execute \texttt{hashFunction(…)} and the rest of the code.\\
If we measure the elapsed time we notice some difference when a username exists and when it does not.\\
In order to avoid these kind of attacks we just need to execute \texttt{hashFunction(…)} even if the username does not exists; in that way we can trick the attacker without providing him valuable information.\\
Let us fix the previous code.\\
\begin{lstlisting}[language=Java]
bool login(String username,char[] password){
	int iter=readIterationFromConfigFile();
	User user=getUserFromDB(username);
	if(user==null){
		String salt=”use this as salt”;
		String hash=hashFunction(password,salt,iter);
		return false;
	}
	String hash=hashFunction(password,user.salt,user.iter);
	if(hash!=user.password)return false;
	if(iter!=user.iter){
		String newSalt=SecureRandomNumberGenerator.generate();
		String newHash=hashFunction(password,newSalt,iter);
		updateUserInDB(username,newHash,newSalt,iter);
	}
	return true;
}
\end{lstlisting}

We just need to perform the hash with dummy data, in order to have a consistent execution time even if the username does not exists.\\
Denial of Service attacks are more common and there is no standard technique to avoid them, for this reason it is difficult to protect against them.\\
A brute force attack could become a DoS if the rate of login attempts is very high. 
An attacker will realistically use an automated tool to perform a DoS attack, the tool will fill the form automatically and perform the request, but you can insert an hidden field, if compiled you can assume that the login attempt was tried by a bot and not by a real user and avoid the allocation of resource to perform the login; this is, of course, a simple trick, if the attacker notices it, he can simply change his tool, but this could stop some script kiddies.\\
A more sophisticated technique is adding a certain amount of time delay every time a login attempt fails in order to slow down the attacker.\\
Locking a certain account is a bad idea because in this way an attacker can deliberately send the wrong credential to lock out legitimate users, this could also lead to a damage image for your company and make your users angry.\\
It may sounds like good idea to block a certain account if you are dealing with sensitive data or money, for example it could be reasonable that a bank locks your account if it notices too much login attempts, but the bank must offer a way to notify you about that and a way to securely unlock your account.\\
Here in Genoa, there is a famous bank that locks your account after five wrong login attempts, and the only way to unlock the account is to go to the bank and talk to an employee that will unlock your account; now suppose that I am abroad, someone lock my account and I need my money for some reason, how am I supposed to unlock it?
Think twice before implementing a locking mechanism. \\

Also, blocking a specific IP address is not a solution, as you may know the Network Address Translation (NAT) is very common in the Internet, so if you block a specific IP you are not blocking a particular user but a group of users that present themselves with that specific IP.\\
Another trick is to add a CAPTCHA after certain numer of failed login, but be sure to add OCR-hard CAPTCHA otherwise an attacker can trick you.\\

\emph{Note:} this is more related to the presentation of your login form but when you need to notify the user that the login was not possible, do not specify why, if you specify that the username did not exists or that the password was wrong you are literally helping the attacker to enumerate the users. Of course for a real user would be more helpful to know if he wrote his username or his password wrong  but for security reason we suggest you to be vague as possible and show the following error message: ``Wrong username or password''.

\section{Handling user privilege}
In a typical client server scenario, checking if a certain user has the privilege to perform a certain operation is crucial to avoid damage to the system and security flaws.\\

I want to highlight that the control logic must be on the server side of the application, the client side could be corrupted or modified by an attacker in ways that allow him to perform operations that are reserved to high privilege users.\\

Control logic client side can be implemented, but keep in mind its main feature is to provide a good user experience to the final user and to avoid useless request to the server. Thus, if he tries to perform a forbidden operation the application shows an error message, but if an attacker modifies it the operation is not performed on the server side.\\

Here we will show you an example of wrong handling of user privilege.\\
\textbf{Note:} we assume that \texttt{performAdminTask(…)} sends a request to the server that triggers the execution of the server side code.

\begin{lstlisting}
//client side
if(role==Admin)
	performAdminTask(username,password);

//server side
eraseDatabase();
\end{lstlisting}

This first example of server side code is insecure because it does not even check if the credentials used to perform the operation are valid, it may seems strange that someone will write a code like that, but it is possible, maybe the developer forgot it or he did not know nothing about security.\\

\begin{lstlisting}

//Client side code
performAdminTask(username,password);

//Server side code
if(login(username,password)){
	eraseDatabase();
}
\end{lstlisting}

The second example at least check if the user exists but does not check if the user has the permission to execute the task.\\
Now we will show you another example where the control logic is on the client side, as before we assume that \texttt{performAdminTask(…)} sends a request to the server that triggers the execution of the server side code.\\

In this case the control logic is only on the client side, so the server is blindly accepting every request that the client sends because it trusts the client, but as just said: never trust the client.\\
Another example of wrong handling is the following(as before the \texttt{performAdminTask(…)} triggers the execution of server side code).\\

\begin{lstlisting}
//client side
performAdminTask(username,password,role);

//server side
if(login(username,password) && role==Admin)
	eraseDatabase();
\end{lstlisting}


In this case we are near to a correct solution, but we are trusting the client: if the client tells the server that he is an administrator, then the server will trust him and perform the action.\\
This is not good because the server must not be tricked in such an easy way, in order to really trust the role associated to a user we need to rely on a secure source of information, and in this case the source is the server itself.\\
You must design your application in way that minimize the exchange of sensitive data between the client and the server, in order to perform actions on the server we just need to send the username and the password (and other parameter if needed), everything else must be on the server.\\
The correct way to check for user privilege is the following:

\begin{lstlisting}
//client side
performAdminTask(username,password);

//server side
if(login(username,password) && getRoleFromDB(username)==Admin)
	eraseDatabase();
\end{lstlisting}

Note that when the client/server application relies on a browser for the client side, it is trivial to edit the code and perform dangerous operation on the server if it is not properly secured.\\
If your client is a standalone application it could be more difficult to edit in order to send malicious requests to the server, but do not rely on this assumption: always secure your server.\\
Also note that data may not come from your client, an attacker could forge request easily with tools like cUrl, Postman or Telnet.\\
What we have seen at the moment is an approach that could work, but does not respect the least privilege principle.\\
This principle states that a user must have only those privileges which are essential to perform its intended function.\\
Basically, if an administrator is working on a simple text file and it only requires the privilege to edit and save this file, he does not need to have the privilege to perform operations on a database; if in future he will need to perform operations on a database then the privilege shall be granted to him and revoked after the operations have been performed.\\
The least privilege principle has been implemented for several years on UNIX like systems, recreating the same functionality is not an easy task and you should ask yourself if your application really needs a privilege system that respect this principle.

\section{Use encrypted communication channel}
In order to minimize the number of attacks you should always use encrypted communication channels, most of the time
using an encrypted channel will not degrade the performance of your application.\\
The only boring thing about using secure protocols is obtaining a proper certificate. In order to establish a secure communication you should have
a certificate provided by a Certificate Authority, for debug purposes you can use a self signed certificate.\\


